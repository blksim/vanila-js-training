### 14.1 HTTP를 안전하게 만들기
**HTTPS**
- HTTPS는 HTTP 트랜잭션을 안전하게 만드는 가장 인기있는 방식
- URL이 https://로 시작
- HTTPS 사용 시, 모든 요청과 응답 데이터는 네트워크를 타기 전 암호화된다
- HTTPS는 HTTP와 달리 하부에 보안 계층이 추가되어, 인코딩 디코딩은 여기에서 이루어진다.
- 네트워크 인터페이스(데이터링크 계층) --> IP(네트워크 계층) --> TCP(전송 계층) --> **SSL 혹은 TLS(보안 계층)** --> HTTP(애플리케이션 계층)

### 14.3 대칭키 암호법
- 대칭키 암호 알고리즘은 인코딩할 때와 디코딩할 때 사용하는 키가 같다.
- 그러므로 인코딩과 디코딩에 사용할 키는 암호화되어 공유되어야 한다.
> 발송자는 공유된 비밀 키를, 메시지를 암호화하고 그 결과인 암호문을 수신자에게 발송하기 위해 사용한다. 수신자는 역시 암호문을 받은 뒤 같은 공유된 키를 사용하여 원래의 평문을 복원하기 위해 해독 함수를 적용한다.<br>
> 잘 알려진 대칭키 암호 알고리즘으로는 DES, Triple-DES, RC2, RC4 등이 있다.(p362)

- 결국 비밀 키가 무엇인지 알아내면 된다.
- 좋은 암호 알고리즘은 무차별 대입 공격밖에는 답이 없는 알고리즘인데, 당연히 이 공격은 비용을 많이 들일 수록 키를 알아내는 데 걸리는 기간이 짧아진다.
- 하지만 아무리 비용을 들여도 실질적으로 깨트릴 수 없는 키는 128비트 키다. 키를 알아내려면 우주의 나이(13.8억년)보다 오래 걸린다.
- 대칭키 암호의 단점은 통신을 위해 키를 공유하고 있어야 한다는 것이다. 만약 A와 B와 C가 모두 J와 대화하길 원한다면, J는 상대에 대한 비밀키를 각각 발급해야 한다. 관리하는 입장에서 번거롭다.

### 14.4 공개키 암호법
- 대칭키 암호법과 달리, 두 개의 비대칭 키를 사용한다. 하나는 호스트의 메시지를 인코딩하기 위한 것이고, 하나는 호스트의 메시지를 디코딩하기 위한 것이다. 키는 모두에게 공개돼있지만, 개인 디코딩 키는 호스트만이 알고있다. 대칭키 암호법은 상대마다 키를 발급해야 하지만, 여기서는 같은 공개키 하나를 사용할 수 있다. 하지만 메시지를 디코딩할 수 있는 능력은 호스트에게만 부여된다.
> 그러나 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있다. 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다.<br>
> 예를 들어, 노드들 사이의 안전한 의사소통 채널을 수립할 때는 편리하게 공개 키 암호를 사용하고, 이렇게 만들어진 안전한 채널을 통해 임시의 무작위 대칭 키를 생성하고 교환하여 이후의 나머지 데이터를 암호화할 때는 빠른 대칭 키를 사용하는 방식이 흔히 쓰인다.(p367)

### 14.5 디지털 서명
- 디지털 서명은 누가 메시지를 썼는지, 메시지가 위조되지는 않았는지 증명하기 위해 메시지에 서명하는 기법이다.
- 서명은 암호 체크섬이며 저자만 갖고 있고, 계산할 수 있다.
- 체크섬은 개인 비밀키에 관련된 것이므로, 체크섬이 맞지 않는 위조 메시지를 가려내는 효과가 있다.
- 디지털 서명은 보통 비대칭 공개키에 의해 생성되며, 오직 소유자만 알고 있다.
- 서명 과정은 다음과 같다(p367)
> 1) 노드 A는 가변 길이 메시지를 고정 길이 요약(digest)로 만든다.<br>
> 2) 노드 A는 그 요약에, 사용자의 개인 키를 매개변수로 하는 '서명' 함수를 적용한다.<br>
> 3) 한 번 서명이 계산되면, 노드 A는 그것을 메시지의 끝에 덧붙이고 메시지와 그에 대한 서명 둘 다를 노드 B에게 전송한다.<br>
> 4) 메시지를 받은 노드 B가, 만약 그 메시지를 쓴 것이 정말로 노드 A이며 동시에 위조되지도 않았다는 것을 확인하길 원한다면, 노드 B는 서명을 검사할 수 있다. 공개키를 이용한 역함수를 사용하는데, 풀어낸 요약이 만약 노드 B가 갖고 있는 버전의 요약과 불일치하면, 메시지가 송신 중에 위조되었거나 아니면 발송자가 노드 A의 개인키를 갖고 있지 않은 것이다.(따라서 메시지를 쓴 것은 노드 A가 아니다.)

### 14.6 디지털 인증서
- 디지털 인증서에 대한 단일 표준은 없으며, X.509라고 불리는 서식이 널리 사용된다.
- X.509 인증서의 필드들은 다음과 같다. (p370~371)
  - 버전 : X.509 인증서 버전의 번호
  - 일련번호 : 인증기관에 의해 생성된 고유의 함수
  - 서명 알고리즘 ID : 서명을 위해 사용된 암호 알고리즘
  - 인증서 발급자 : 인증서를 발급하고 서명한 기관의 이름
  - 유효기간 : 인증서의 유효기간
  - 대상의 이름 : 인증서에 기술된, 사람이나 조직 같은 엔터티
  - 대상의 공개 키 정보 : 인증 대상의 공개 키, 공개 키에 사용된 알고리즘, 추가 매개변수
  - 발급자의 고유 ID(선택) : 발급자의 이름이 겹치는 경우를 대비한, 인증서 발급자에 대한 선택적인 고유한 식별자.
  - 대상의 고유(선택) : 대상의 이름이 겹치는 경우를 대비한, 인증 대상에 대한 선택적인 고유 식별자
  - 확장 : 선택적인 확장 필드의 집합. 기본 제약, 인증서 정책, 키 사용에 대한 내용이 추가될 수 있음
  - 인증기관 서명 : 위의 모든 필드에 대한 인증기관의 디지털 서명. 명시된 알고리즘을 사용
 
 **서버 인증을 위해 인증서 사용하기** (p371~372)
 > 사용자가 HTTPS를 이용한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다. 만약 서버가 인증서를 갖고 있지 않으면 보안 커넥션은 실패한다.<br>
 > 브라우저가 인증서를 받으면, 서명 기관을 검사한다. 만약 그 기관이 공공이 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고 있을 것이며(브라우저들은 여러 서명 기관의 인증서가 미리 설치된 채로 출하된다.), 브라우저는 그 서명을 검증할 수 있다.<br> 
 > 만약 서명 기관이 모르는 곳이라면, 브라우저는 그 서명 기관을 신뢰해야 할지 확신할 수 없으므로, 대개 사용자가 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 보여준다.
 
 ### 14.7 HTTPS의 세부사항
 - HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다.
 - HTTP는 보안 계층을 거치지 않는 대신에, HTTPS는 TCP로 메시지를 보내기 전 보안 계층을 거쳐 메시지를 암호화한다.
 - 오늘날의 HTTPS는 SSL과 그것의 현대적 대체품인 TLS로 구현되었다.
 - HTTPS의 스킴 접두사는 https로, 웹브라우저와 같은 클라이언트는 트랜잭션 수행 시 URL 스킴이 http이면 80번 포트를 통해 평범한 HTTP 명령을 전송한다.
 - URL 스킴이 https면 클라이언트는 서버에 443포트로 연결하고, SSL 보안 매개변수를 교환하면서 핸드셰이크를 한 다음, 암호화된 메시지가 HTTPS 터널을 통과한다.
 
 **SSL 핸드셰이크** (p376)
 - HTTP 메시지를 보내기 전, 클라이언트와 서버는 SSL 핸드셰이크를 해야 한다. 
 - 핸드셰이크 과정에서는 프로토콜 버전 번호 교환, 양쪽이 알고 있는 암호 선택, 양쪽의 신원 인증, 채널 암호화 위한 세션 키 생성과 같은 일이 일어난다
   (1) 클라이언트가 암호 후보들을 보내고 인증서를 요구한다
   (2) 서버는 선택된 암호와 인증서를 보낸다
   (3) 클라이언트가 비밀정보를 보낸다. 클라이언트와 서버는 키를 만든다.
   (4) 클라이언트와 서버는 서로에게 암호화를 시작한다고 말해준다.
 
 - 넷스케이프가 제안한 웹 서버 인증서 검사를 위한 한 알고리즘은 대부분의 웹 브라우저 검사 기법의 기초를 구축했다.
 1) 먼저 브라우저는 인증서의 유효기간을 검사하고, 만료됐거나 비활성화됐으면 에러를 띄운다.
 2) 브라우저는 신뢰할 만한 기관의 목록을 포함된 채로 배포되는데, 만약 잘 알려져있지 않은 기관이거나 악의적인 서명이 포함된 인증서를 받으면 브라우저는 경고를 표시하고, 사용자는 그 인증서를 신뢰할 지 여부를 선택할 수 있다.
 3) 한번 믿을만 하다고 생각되면, 브라우저는 인증서의 공개키를 서명의 적용하여 그의 체크섬과 비교해봄으로써 무결성을 검사한다.
 4) 대부분의 브라우저는 인증서의 도메인 이름이 대화중인 서버의 도메인 이름과 일치하는 지 검사한다. 신원이 맞지 않을 경우, 클라이언트는 반드시 이 사실을 사용자에게 알리거나, 잘못된 인증서 에러와 함께 커넥션을 끊는다.
 
 - SSL은 복잡한 바이너리 프로토콜이기에, SSL 클라이언트와 서버 프로그래밍을 도와주는 상용 혹은 오픈소스 라이브러리를 사용한다.
 - 대표적으로 OpenSSL이 있다. 
 
### 14.9 프락시를 통한 보안 트래픽 터널링
- 클라이언트는 종종 웹 프락시 서버를 이용하여 대신 웹 서버에 접근하도록 한다.
- 그러나 클라이언트가 서버의 공개키로 데이터를 암호화하기 시작하면 프락시는 HTTP 헤더를 읽을 수 없다.
- HTTPS가 프락시와 잘 동작하게 하려면, SSL 터널링 프로토콜이 필요하다.
- HTTP는 CONNECT라는 확장 메서드를 사용해 프락시가 연결하기 원하는 호스트와 포트 번호를 받아 데이터가 오갈 수 있는 터널을 만든다.
> CONNECT 메서드는, 안전한 원 서버의 호스트명과 포트를 콜론으로 구분된 형태로 제공하는, 한 줄로 된 텍스트 명령이다.  이 호스트:포트에 뒤이어 스페이스 하나와 HTTP 버전 문자열과 CLRF가 순서대로 온다. 0개 이상의 HTTP 요청 헤더줄들이 이어진 다음, 빈 줄 하나가 온다. 빈 줄 다음에, 만약 커넥션을 수립하기 위한 핸드셰이크가 성공했다면, SSL 데이터 전송이 시작된다.
```
CONNECT home.netscape.com:443 HTTP/1.0
User-Agent: Mozilla/1.1N

<SSL로 암호화된 데이터가 이 다음에 온다 ...>
```
- 프락시가 목적지와 연결되고 나면 200 응답을 클라이언트에게 보낸다.
```
HTTP/1.0 200 Connection established
Proxy-agent: Netscape-Proxy/1.1
```
