### 8.1 게이트웨이 (p228)
> 게이트웨이는 리소스와 애플리케이션을 연결하는 역할을 한다.<br>

> 게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 한다.<br>

> 상이한 HTTP 버전 사이에서 변환을 수행하는 웹 프락시는 게이트웨이와 같다. 그 웹 프락시는 양쪽 사이에서 교섭을 위한 복잡한 로직을 수행하기 때문이다. 하지만 양쪽에서 HTTP로 통신하기 때문에, 기술적으로는 프락시다.
- 클라이언트 측 게이트웨이와 서버 측 게이트웨이의 프로토콜은 빗금(/)으로 구분하여 표시한다.

### 8.2 프로토콜 게이트웨이
- 네트워크 상에서 클라이언트와 서버를 연결하는 게이트웨이

**HTTP/* : 서버 측 웹 게이트웨이**
> 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 게이트웨이는 클라이언트 측의 HTTP 요청을 외래 프로토콜(예: FTP)로 전환한다.(p231)

**HTTP/HTTPS : 서버 측 보안 게이트웨이**
- 모든 웹 요청을 암호화하는 데 사용

**HTTPS/HTTP : 클라이언트 측 보안 가속 게이트웨이**
- 보안 트래픽을 받아서 복호화하여 웹 서버로 보낼 일반 HTTP 요청을 만듦
- 게이트웨이와 원 서버 간에 있는 네트워크가 안전한지 확실히 검증 필요

### 8.3 리소스 게이트웨이
- 게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 HTTP를 통해 클라이언트와 통신하고, 서버 측 애플리케이션 프로그램과 연결하는 *서버 측 게이트웨이*다.(p233)
- 애플리케이션 서버는 API를 통해 서버에 요청을 전달한다. 최초의 API는 공용 애플리케이션 인터페이스(Common Gateway Interface:CGI)였다.

> 게이트웨이를 통해야 받을 수 있는 리소스 요청이 들어오면, 서버는 헬퍼 애플리케이션을 생성하여 요청을 처리한다. 헬퍼 애플리케이션은 필요한 데이터를 전달받는다. 전달받은 데이터는 요청 전체이거나 사용자가 데이터베이스에서 실행시키려는 질의 같은 것이다. 그 다음, 바로 클라이언트로 전달할 응답이나 응답 데이터를 서버에 반환한다. 서버와 게이트웨이는 별개의 애플리케이션이기 때문에 각각 가지고 있는 책임은 분명히 나뉘어 있다. 이 단순한 프로토콜(요청을 받아 처리해서 응답하는)은 가장 오래된 서버 확장 인터페이스인 CGI이다.(p234~235)

### 8.5 터널
> 웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방식을 제공한다.(p237)

**CONNECT 메소드**
- HTTP 확장인 CONNECT 메서드를 사용하여 터널 커넥션을 맺는다.
- CONNECT 메서드는 게이트웨이에 TCP 커넥션 요청을 보내고, 커넥션이 맺어지는 시점에 터널이 연결된다
- 그 이후 클라이언트에서 보내는 모든 데이터는 터널을 거친다
- 응답 시 별도의 미디어 타입은 정의할 필요가 없다.

**SSL 터널링**
- 웹 터널은 SSL과 같이 암호화된 트래픽을 HTTP 커넥션으로 전송할 수 있도록 한다.
- SSL 터널링 기능은 HTTP가 아닌 트래픽이 방화벽을 통과할 수 있게 해 주지만, 악의적인 트래픽이 유입되는 경로가 될 수도 있다.

> 터널 게이트웨이는 해당 프로토콜이 터널을 올바른 방식으로 사용하고 있는 지 알 수 없기 때문에, HTTPS 전용 포트인 443과 같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해야 한다.(p244)

### 8.6 릴레이
- HTTP 릴레이는 엄격하게 헤더와 메서드를 구현하지 않는, 단순한 트래픽을 맹목적으로 전송하는 간단한 프락시다.
- 하지만 Connection 헤더를 지원하지 못하는 릴레이의 경우 hop-by-hop이 지켜지지 않은 상태에서 keep-alive 요청을 그대로 서버로 전달함으로써, 클라이언트가 아닌 릴레이와 서버 간 keep-alive가 성립된다. 
- 릴레이는 서버로부터 받은 데이터를 클라이언트에게 넘겨주지만, 클라이언트가 아무리 새로운 요청을 보내도, 릴레이는 인지하지 못하고 서버가 커넥션을 끊기를 기다린다
