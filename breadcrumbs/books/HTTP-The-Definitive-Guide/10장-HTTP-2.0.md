### 10.1 HTTP/2.0의 등장 배경
- HTTP/1.1의 메시지 포맷은 구현 단순성과 접근성에서는 우수했지만, 한 요청 당 하나의 응답만을 허용하는 메시지 교환 방식의 특성상 *회전 지연* 문제가 있었다.
- 파이프라인 커넥션은 이를 해결하기 위한 방안 중 하나였지만, 
- 근본적인 성능 문제를 해결하기 위해 여러 프로토콜이 제안되었다.
- 그 중 구글의 SPDY를 기반으로 한 HTTP/2.0 초안 제작이 2012년부터 시작됐으며 2015년 RFC 7540 표준안까지 나와있다.

### 10.3 HTTP/1.1과의 차이점
**프레임**
  - 메시지가 8바이트 헤더 + ~16383바이트 페이로드로 구성된 프레임에 담긴다. 헤더 구조는 다음과 같다.
  1) R : 2비트 예약 필드. 반드시 0이어야 함
  2) 길이 : 14비트 정수로 페이로드 길이를 나타낸다
  3) 프레임 종류(DATA, HEADERS, PRIORITY, RST_STREAM, SETTINGS, PUSH_PROMISE, PING, GOAWAY, WINDOW_UPDATE, CONTINUATION)
  4) 플래그 : 프레임 종류에 따른 8비트 플래그 값
  5) R : 1비트 예약 필드
  6) 스트림 식별자 

**스트림과 멀티플렉싱**
> 스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.(p290)
- 한 쌍의 요청-응답은 한 개의 스트림을 통해 이루어진다.
- *하나에 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다*.
- 리소스의 중요도에 따라서 웹 브라우저는 더 중요한 스트림에게 높은 우선순위를 부여할 수도 있다.

**헤더 압축**
- 헤더를 보낼 때 조각내어 압축하고, 받을 때 조각을 이어 압축을 푼다. 
- HPACK 명세에 따라 압축하고 해제할 때 '압축 콘텍스트'를 사용한다.
- 압축 콘텍스트는 압축 상태에 대한 정보로 수신 후 압축을 풀면 바뀐다.

**서버 푸시**
- 리소스 재요청과 회전 지연을 개선하기 위해, 서버는 하나의 요청에 대해 여러 리소스로 응답할 수 있다.
- 서버가 클라이언트에 `PUSH_PROMISE` 프레임을 전송하면, 클라이언트는 서버 푸시가 이루어질 것임을 인지하고 해당 프레임을 예약상태로 둔다.
- 클라이언트는 `RST_STREAM` 프레임을 보내어 서버 푸시를 거절하고 프레임을 닫을 수도 있다.
> - 서버 푸시를 사용하기로 했더라도, 중간의 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있으며, 반대로 아무런 추가 리소스를 서버로부터 받지 않았음에도
클라이언트에게 추가 리소스를 전달할 수도 있다.<br>
> - 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시를 할 수 있다.(p293)

### 10.4 알려진 보안 이슈
- 중개자 캡슐화 공격 : 프락시가 HTTP/2.0 메시지를 HTTP/1.1로 변환하는 과정에서 바이너리로 인코딩된 헤더의 오번역을 유발할 수 있다.(예:줄바꿈문자)
- 긴 커넥션 유지로 인한 개인정보 누출 우려 : 회전 지연을 막기 위한 커넥션 유지로 인해, 이전 사용자의 사용 기록을 알아낼 수 있다. 짧은 커넥션보단 긴 커넥션 유지 시 상대적으로 누출 우려가 높다는 의미.
