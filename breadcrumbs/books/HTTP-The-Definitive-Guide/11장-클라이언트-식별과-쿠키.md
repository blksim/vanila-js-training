- 웹 서버는 수많은 클라이언트의 요청을 처리할 뿐만 아니라 식별해야 하는 수도 있다.

### 11.2 HTTP 헤더(p299)
- From : 사용자의 이메일 주소. From 헤더의 이메일을 모아 스팸을 발송하는 악의적인 서버가 있어 현재는 거의 사용하지 않음
- User-Agent : 사용자의 브라우저. 
- Referer : 사용자가 현재 링크를 타고 온 근원 페이지
- Authorization : 사용자 이름과 비밀번호
- Client-ip(확장) : 클라이언트의 IP 주소
- X-Forwarded-For(확장) : 클라이언트의 IP 주소
- Cookie(확장) : 서버가 생성한 ID 라벨

### 11.3 클라이언트 IP 주소
- 클라이언트를 IP 주소로 구분하는 방식은, 인트라넷처럼 제한된 영역에서는 적절할 수 있다
- 하지만 인터넷 서비스 사용자(ISP)는 동적으로 IP 주소를 할당하므로, IP 주소로 클라이언트를 식별하는 것은 적절하지 않다
- 클라이언트 IP 주소는 사용자가 아닌 컴퓨터를 나타내며, 여러 사람이 이용할 경우 식별 불가하다.
> 보통, HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 한다. 웹 서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP 주소를 본다. 
> 일부 프락시는 원본 IP 주소를 보존하려고 Client-ip나 X-Forwarded-For HTTP 같은 확장 헤더를 추가하여 이 문제를 해결하려 했다. 하지만 모든 프락시가 이런 ㅎ식으로 동작하진 않는다.

### 11.4 사용자 로그인
- 웹 서버가 명시적 로그인 요청을 하여 사용자를 식별할 수도 있다.
- 브라우저가 요청하면 -> 서버는 401 Login Required HTTP 응답 코드와 Authenticate 헤더를 반환하여 로그인을 요청한다 -> 사용자가 대화상자에 로그인 정보를 입력하면 브라우저는 사용자 식별 정보를 얻게 되고,
한 번만 로그인하면 세션이 유지되는 동안은 식별을 유지한다.

### 11.5 뚱뚱한 URL(p304)
- 사용자의 상태정보를 의미하는 식별번호가 동적으로 추가된 URL을 뚱뚱한 URL이라고 부른다. 
> - 웹 서버와 통신하는 독립적인 HTTP 트랜잭션을 하나의 '세션' 혹은 '방문'으로 묶는 용도
> - 사용자가 웹 사이트에 처음 방문하면 유일한 ID가 생성되고, 그 값은 서버가 인식할 수 있는 방식으로 URL에 추가되며, 서버는 클라이언트를 이 뚱뚱한 URL로 리다이렉트시킨다.
> - 서버가 뚱뚱한 URL을 포함한 요청을 받으면, 사용자 아이디와 관련된 추가적인 정보(쇼핑 카트, 프로필 등) 를 찾아서 밖으로 향하는 모든 하이퍼링크를 뚱뚱한 URL로 바꾼다.

하지만,
- URL이 지나치게 길어져 사용자들에게 혼란을 준다.
- URL에 사용자 정보가 포함되므로, 누군가에게 URL을 공유한다면 개인 정보를 공유하는 셈이다
- 기존 캐시에 접근할 수 없다는 것을 의미한다.
- 서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야 하므로 서버에 부하를 유발할 수 있다.
- 사용자가 다른 URL로 이탈하는 경우, 기존 진척상황들(예: 장바구니)이 초기화되어 처음부터 다시 시작할 수도 있다.
- 뚱뚱한 URL을 북마크하지 않는 이상, 로그아웃하면 모든 정보를 잃는다.

### 11.6 쿠키
> - 쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식이다.
- 쿠키는 사용자가 사이트를 탐색하는 동안 관련 사항을 저장했다가, 브라우저를 종료하면 삭제되는 세션 쿠키와,
자주 방문하는 사이트 정보나 아이디 등을 디스크에 영속적으로 저장하는 지속 쿠키로 나눌 수 있다.
- 쿠키는 다시 방문한 사용자를 식별하기 위해 사용되는 기술이며, 웹 서버에서 응답 시 키=값 형태의 데이터를 Set-Cookie 헤더에 담아 사용자에게 전달한다.
- Set-Cookie 헤더에 Domain 속성을 사용하면, 쿠키를 읽을 수 있는 사이트를 제어할 수 있다.
- Path 속성을 사용하면, URL 앞부분(경로)가 같은 페이지에만 쿠키가 전달된다.

**쿠키 구성요소**
- Version 0(넷스케이프 쿠키) : 최초의 Set-Cookie 응답 헤더, Cookie 요청 헤더 명세
- Version 1(RFC 2965) 쿠키 명세는 폐기되어 더 이상 지원되지 않음. 
참고:
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie <br>
https://tools.ietf.org/html/rfc6265#section-4.1 

**캐시를 다루는 기본 원칙**
- 캐시해도 되는 문서에 Cache-Control: public을 사용하면 대역폭을 절약해줌
- Set-Cookie 헤더를 캐시할 경우 사용자 추적에 실패할 수 있다. Cache-Control 헤더에 must-revalidate, max-age=0과 같은 값을 추가하여 무조건 캐시에서 원 서버에 재검사 요청하도록 할 수 있다. 
- Cookie 헤더를 포함한 요청이 오면 개인정보를 포함할 수 있다는 의미. 아예 캐시하지 않거나, 파기 시간이 0인 Cookie 헤더를 설정해서 매번 재검사할 수도 있다.
> 가장 큰 오용 중 하나는 협력업체 웹 사이트가 사용자를 추적하려고 지속 쿠키를 사용하는 것이다. 이것을 IP 주소와 Referer 헤더에 있는 정보와 함께 사용하면, 마케팅 회사들은 사용자의 프로필과 사용 패턴에 대해 꽤 정확한 데이터를 수집할 수 있다.<br>
> 쿠키에 대한 부정적인 여론이 많기는 하지만, 제공하는 개인정보를 누가 받는지 명확히 알고 사이트의 개인정보 정책에만 유의한다면, 쿠키에 관련한 위험성보다 세션 조작이나 트랜잭션상의 편리함이 더 크다.(p319)
