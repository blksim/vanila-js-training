> 콘텐츠 리소스를 저장, 중개, 관리하는 일을 통틀어 웹 호스팅이라고 한다. 
> 호스팅은 웹 서버의 가장 중요한 기능 중 하나다. 콘텐츠를 저장해서 제공하고 관련 로그에 접근하거나 그것을 관리하는 데 서버가 필요하다.
> 필요한 하드웨어와 소프트웨어를 직접 관리하기 어렵다면, 호스팅 서비스나 호스팅 업체가 필요할 것이다. 호스팅 업체는 서버와 웹 사이트 관리 프로그램을 대여해주고 다양한 등급의 보안, 리포트, 사용 편의를 제공한다.
> 보통 호스팅 업체는 경제적이면서도 믿을 수 있고 성능 좋은 웹 사이트를 제공하기 위해 잘 손상되지 않는 공용 웹 서버에 올린다. (p475)

### 18.1 호스팅 서비스
> 월드 와이드 웹 초기에는 각 회사가 자체 컴퓨터 하드웨어를 구매하고 자체 컴퓨터 망을 구축하며 자체 네트워크 연결을 확보하고 자체 웹 서버 소프트웨어를 관리했다.<br>

> 웹이 빠르게 대세가 되면서, 모든 사람이 웹 사이트를 원했지만, 냉난방 장치가 있는 서버실을 짓고 도메인 이름을 등록하고 네트워크 대역폭을 구매할 기술과 시간을 가진 사람은 드물었다.<br>
> 그 시간을 절약하기 위해, 전문적으로 관리하는 웹 호스팅 서비스를 제공하는 여러 신사업이 만들어졌다. 물리적인 장비 관리(공간, 냉난방, 연결)에서부터 고객이 직접 콘텐츠를 제공할 수 있는 총체적인 웹 호스팅까지 다양한 종류의 서비스가 있다.

### 18.2 가상 호스팅
- 많은 사람들이 웹에 자기만의 공간을 갖고 싶어하고, 이들의 웹은 하루 종일 대량 트래픽이 발생하는 게 아니기 때문에 전용 웹서버는 과하다.
- 이들을 위해 웹 호스팅 업자는 한 대의 서버를 많은 사람들이 공유하게 한다.
- 최종 사용자가 겉으로 보기엔 사이트마다 각각 다른 서버가 콘텐츠를 제공하는 것처럼 보이지만, 물리적으로는 동일한 서버가 제공하는 것이다.

- HTTP/1.0 명세에는 호스트 정보 식별 기능을 제공하지 않는 결함이 있어 가상 호스팅하기 어려웠다.
- 예를 들어, 클라이언트에서 index.html이라는 문서를 서버에 요청하면 실제로 호스팅 서버에서 여러 호스트의 index.html이 존재함에도
HTTP/1.0에서는 호스트를 식별하지 못하므로 요청 자체는 동일하게 보인다는 것이다.
- 당시 설계자들이 각 웹 서버당 한 웹사이트만 호스팅할 거라고 여기고, 공유 서버인 가상 호스팅을 고려하지 않았기 때문이다.
- 이는 전체 URL을 HTTP 요청에 포함하도록 함으로써 해결됐다. 

**URL 경로를 통한 가상 호스팅**
- 호스팅 서버에 올라가 있는 각 가상 사이트에 서로 다른 URL을 할당해서 강제로 구분한다.
- 호스트명이 포함되어있지 않아도, 경로에 포함된 /joe, /mary같은 식별 접두어를 통해 구분하는 방식이다.
- 이는 불필요하고 혼란스러우며 http://www.joes-hardware.com/index.html과 같은 일반적인 리소스 접근 방식이 동작하지 않게 하므로 거의 사용하지 않는다.

**포트번호를 통한 가상 호스팅**
- 경로명을 변경하는 대신 포트를 다르게 준다.
- 하지만 이 경우에도 마찬가지로, 비표준 포트를 쓰지 않고 사이트 이용을 원하는 사용자 때문에 좋은 방법이라고 할 수 없다.

**IP 주소를 통한 가상 호스팅** (p481)
- 가상 IP를 사이트마다 한 개 이상 부여한다.
  1. 클라이언트 A는 http://www.joes-hardware.com/index.html를 요청한다.
  2. 클라이언트 A는 www.joes-hardware.com의 IP 주소를 요청해 209.172.34.3을 얻는다.
  3. 클라이언트 A는 209.172.34.3에 있는 공용 웹 서버에 TCP 커넥션을 맺는다.
  4. 클라이언트 A는 "GET /index.html HTTP/1.0" 요청을 보낸다.
  5. 웹 서버가 응답을 전송하기에 앞서, 실제 목적지 IP 주소(209.182.34.3)를 기록하고, 이것이 죠의 웹 사이트에 대한 가상 IP 주소라는 것을 판단하고, /joe 하위디렉터리에서 요청을 처리한다.
  /joe/index.html 페이지를 반환한다.

- 이는 잘 동작하지만, 규모가 아주 큰 호스팅 업체에게는 단점이 있다.
- 장비에 연결할 수 있는 IP 갯수에는 제한이 있으며, IP 주소 자체도 희소자원이다.
- 여기에 서버를 복제할 경우 서버 수만큼 IP 주소가 더 필요해진다.
- 하지만 널리 쓰이는 방식

**Host 헤더를 통한 가상 호스팅**
- HTTP/1.0 당시 서버가 원 호스트명을 받아볼 수 있게 HTTP가 확장됐지만, 
여전히 서버는 경로 컴포넌트만 인식해서 아무리 브라우저에서 전체 URL을 보내도 소용없었다.
- 그래서 HTTP Host 확장 헤더에 가상 호스트명과 포트번호를 기술하여, 같은 IP주소를 쓰더라도 호스트를 식별할 수 있게 한다.

**HTTP/1.1 Host 헤더**
> 현재는 모든 브라우저가 Host 헤더를 전송한다. (p485)
- Host 헤더에는 원본 URL에 있는 요청 리소스에 대한 인터넷의 호스트와 포트번호를 기술한다.
```
Host = "Host" : "호스트[":"포트]
```
- Host 헤더에 포트가 기술되어 있지 않으면, 해당 스킴의 기본 포트를 사용한다.
- URL에 IP주소가 있으면, Host 헤더는 같은 주소를 포함해야 한다.
- URL에 호스트명이 기술돼 있으면, Host 헤더는 같은 호스트명을 포함해야 한다.
- URL에 호스트명이 기술돼 있으면, Host 헤더는 호스트명이 가리키는 IP 주소를 포함해서는 안 된다. 여러 개의 가상 사이트에서 한 IP 주소에 연결하는 가상 호스트 서버에서 문제가 될 수 있다.
- 클라이언트가 특정 프락시 서버를 사용한다면, Host 헤더의 프락시 서버가 아닌 원 서버의 호스트명과 포트를 기술해야 한다. 
- 웹 클라이언트는 모든 요청 메시지에 Host 헤더를 기술해야 한다.
- 웹 프락시는 요청 전달 전 요청 메시지에 Host 헤더를 추가해야 한다.
- HTTP/1.1 웹 서버는 Host 헤더 필드가 없는 HTTP/1.1 요청을 받으면 400 상태코드로 응답해야 한다. (p484)


- 호스트를 기준으로 리소스를 구분하는 모든 웹 서버는 HTTP/1.1을 통해 오는 리소스를 결정할 때 다음과 같은 규칙을 사용한다. (p485)
1. HTTP 요청 메시지에 전체 URL이 기술돼 있으면 Host 헤더 값은 무시하고 URL을 사용한다.
2. HTTP 요청 메시지에 있는 URL에 호스트명이 기술되어 있지 않고 요청에 Host 헤더가 있으면, 호스트명과 포트를 Hosts 헤더에서 가져온다.
3. 1단계나 2단계에서 호스트를 결정할 수 없으면 클라이언트에 400 Bad Request 응답을 반환한다. 

### 18.3 안정적인 웹 사이트 만들기
- 웹 사이트의 장애로 분류되는 몇 가지 상황은 다음과 같다 : 서버 다운, 트래픽 폭증, 네트워크 장애나 손실
- 일반적인 문제 해결을 위한 몇 가지 방법은 다음과 같다.

**미러링된 서버 팜**
- 서버 팜은 각 서버가 서로를 대신하며 서로를 식별할 수 있는 웹 서버 집합이다. 
- 마스터 원 서버 - 복제된 원 서버의 계층구조다.
- 마스터 원 서버의 콘텐츠와 복제된 원 서버의 콘텐츠는 정확히 같아야 하는데, 이렇게 서버 팜에 분산 배포하려면 네트워크 스위치가 필요하다.
- 예를 들어 마스터 원 서버가 시카고에 있고, 복제된 원 서버가 뉴욕, 마이애미에 있다면, 시카고의 마스터 서버는 시카고 사용자들에게 서비스를 하면서 동시에 뉴욕, 마이애비 복제 서버에 콘텐츠를 전송하는 역할을 한다.
- 이러한 시나리오에서 클라이언트의 요청이 특정 서버로 전달되는 방법은 두 가지다.
> HTTP 리다이렉션 : 콘텐츠의 대한 URL은 마스터 서버의 IP를 가리키고, 마스터 서버는 요청을 받는 즉시 복제 서버로 리다이렉트시킨다. <br>
> DNS 리다이렉션 : 콘텐츠의 URL은 네 개의 IP 주소를 가리킬 수 있고, DNS 서버는 클라이언트에게 전송할 IP 주소를 선택할 수 있다.(p487) 

**콘텐츠 분산 네트워크(CDN)**
- 말 그대로 콘텐츠 분산을 위한 네트워크이며, 노드는 서버, 대리 서버, 혹은 프락시 서버다.
- 대리 서버(리버스 프락시) : 원 서버를 대신해 요청을 받는다. 즉 원 서버에 대한 요청을 받아 대리해서 처리한다.
- 대리 서버는 수요에 따라서 동작하므로, 클라이언트가 요청하는 콘텐츠만 복제해 갖고 있을 뿐 원 서버의 전체 콘텐츠를 갖고 있지는 않다.
- CDN의 프락시 캐시 : 전통적인 프락시 캐시는 모든 웹서버 요청을 받을 수 있지만, 대리 서버를 사용한다면 프락시 캐시는 요청하는 콘텐츠만 저장한다.
- 물리적으로 모든 HTTP 요청이 캐시를 거치게 할 경우, 스위치 혹은 라우터가 중간에 웹 트래픽을 가로채서 프락시에게 보내기도 한다.
