### 20.1 왜 리다이렉트인가?
- 웹 콘텐츠는 지연 최소화, 네트워크 대역폭 절약을 위해 여러 장소에 배포되는데, 최적의 분산 콘텐츠를 찾아주기 위한 기법의 집합이 리다이렉션이다.

### 20.2 리다이렉트할 곳
- 서버, 프락시, 캐시, 게이트웨이는 클라이언트의 요청을 처리한다는 관점에서 보면 공통적으로 서버의 특성을 갖고 있다. 
> 그러나 어떤 리다이렉션 기술들은 특정 종류의 종단만을 위해 특별히 설계되어 일반적인 적용이 불가능하다.(p523) 

### 20.4 일반적인 리다이렉션 방법
**HTTP 리다이렉션**
- 리다이렉팅 서버가 가용 서버 중 가장 부하가 적은 곳으로 요청을 리다이렉트한다.
- 클라이언트가 요청 -> 서버가 302 상태코드와 함께 리다이렉트 메시지로 응답 -> 클라이언트가 리다이렉트할 서버로 재요청 -> 해당 서버에서 200 상태코드로 응답
- 하지만 단점이 있다. 어떤 서버로 리다이렉트할 지 결정하기 위해 많은 처리가 필요하고, 두 번의 왕복으로 사용자가 오래 기다리며, 리다이렉트 서버가 고장나면 사이트가 작동을 안 한다는 것.
- 그래서 HTTP 리다이렉션은 다른 리다이렉션 기법과 함께 사용된다.

**DNS 리다이렉션**
> DNS는 한 도메인에 여러 아이피 주소가 결부되는 것을 허용하며, 이 중 어떤 아이피 주소를 선택할 것인지 결정해야 한다.
- DNS 라운드 로빈 : 가장 단순하고 흔히 사용되는 리다이렉션 기법. 웹 서버 팜 전체의 부하 균형을 유지하기 위해 목록 첫 번째 주소를 사용하되, 
DNS 룩업이 끝날 때마다 주소들을 순환시킨다.
- DNS 캐싱의 효과 : DNS 주소 순환은 부하를 순환시킨다. 하지만 호스트 하나에 대한 DNS 룩업을 수행한 뒤, 그 주소를 계속 사용함으로써 부하 균형이 제대로 분산되지 않을 가능성이 있다.
> DNS 라운드 로빈은 일반적으로 하나의 클라이언트로 인한 부하를 제대로 분산하지 못한다. <br>
> 그러나 비록 DNS가 단일 클라이언트의 트랜잭션을 서버의 복제들에게 나눠주지는 않더라도, 그것은 여러 클라이언트들의 부하 총량을 분산하는 적절한 작업을 수행한다. 비슷한 요청을 하는 클라이언트의 수가 어느 정도 이상만 된다면, 부하는 모든 서버에 걸쳐 상대적으로 잘 분산될 것이다.(p531)
- 주소 순서를 결정하기 위한 다른 DNS 알고리즘 기법에는 부하 균형 알고리즘, 근접 라우팅 알고리즘, 결합 마스킹 알고리즘이 있다.
- 부하 균형 알고리즘은 웹서버의 로드를 추적해 가장 로드가 적은 웹 서버를 목록 상위에 놓는다.
- 근접 라우팅 알고리즘은 팜이 지리적으로 분산돼있는 경우, 사용자와 근접한 웹 서버로 라우팅한다.
- 결합 마스킹 알고리즘은 네트워크 상태를 모니터링하면서 장애를 피해 라우팅한다.
> 일반적으로, 복잡한 서버 추적 알고리즘을 실행하고 있는 DNS 서버는 콘텐츠 제공자의 통제 하에 있는 권위 있는 서버다.<br>
https://www.techveze.com/understanding-dns-architecture/ <--- 다시 읽어볼 것.

**임의 캐스트 어드레싱**
- 클라이언트와 가장 가까운 서버로 라우팅하기 위해, 백본 라우터의 최단거리 라우팅 능력에 의존하는 리다이렉션 기법이다.
- 지리적으로 흩어진 웹 서버들은 같은 아이피 주소를 갖고 있고, 백본 라우터는 자신이 해당 웹 서버들과 가장 인접한 라우터라고 광고한다.
- 백본 라우터가 임의 캐스트 주소를 향하는 패킷을 받으면, 자신에게 가장 인접한 서버로 라우팅한다.
- 웹서버는 라우터 통신 프로토콜을 이용해 인접한 백본 라우터와 대화한다.
> 분산 임의 캐스트의 동작을 위해, 서버는 반드시 '라우터의 언어로 말해야 하고' 라우터는 일어날 수 있는 주소 충돌을 반드시 다룰 수 있어야 한다.(p533)

**아이피 맥 포워딩** (p534) ----> 이해안됨
- 이더넷에서 HTTP 메시지는 패킷 형태로 보내지는데, 각 패킷은 레이어-4 주소인 아이피 주소와 포트 번호 외에도, 레이어-2 주소인 미디어 접근 컨트롤(Media Access Control:MAC) 주소도 갖고 있다.
> 레이어-2 장비의 역할은 들어오는 특정 MAC 주소의 패킷을 받아서 나가는 특정 MAC 주소로 포워딩하는 것이다.<br>
> MAC 포워딩을 지원하는 레이어-4 스위치는 보통 요청을 여러 프락시 캐시로 보낼 수 있고 그들 사이의 부하 균형을 유지할 수 있다.<br> 
> MAC 주소 포워딩은 점대 점으로만 가능하기 때문에, 서버나 프락시는 스위치와 한 홉 거리에 위치해야 한다.

**아이피 주소 포워딩** (p535) ----> 이해안됨
- 레이어-4를 이해하는 장비는 패킷의 TCP/IP 어드레싱을 검증하고 아이피 주소 변경에 따라 라우팅한다.
- 맥 포워딩과 달리 목적지 서버가 한 홉 거리에 있을 필요가 없다.
> 그러나 라우팅 대칭성때문에 TCP 커넥션을 관리하는 스위치는 반드시 그 커넥션을 통해서 클라이언트에게 응답을 돌려주어야 하므로, 목적지 서버나 프락시로부터의 응답은 반드시 스위치에게 돌아가야 한다.<br>
- 응답 귀환 경로를 제어할 수 있는 방법은 두 가지다.
> 패킷의 출발지 아이피 주소를 스위치의 아이피 주소로 바꾼다. 목적지와 출발지의 아이피주소 양쪽을 번역하는 장치를 완전 NAT이라고 하는데, 그러면 결제나 인증 시 웹 서버가 클라이언트의 아이피 주소를 알 수 없게 된다.<br>
> 만약 출발지 아이피 주소가 그대로 남아있다면, 서버에서 클라이언트로 바로 가는 경로가 존재하지 않아야 한다. 여기서 장점은 서버가 클라이언트 아이피 주소를 얻는다는 거싱며, 단점은 클라이언트와 서버 사이의 네트워크 전체에 약간의 통제가 필요하다는 것이다.<br>

**네트워크 구성요소 제어 프로토콜(Network Element Control Protocol, NECP)**
> 패킷을 전달하는 라우터나 스위치 같은 네트워크 구성요소(NE)들이 웹 서버나 프락시 캐시와 같이 애플리케이션 계층 요청을 처리하는 서버 구성요소들(SE)과 대화할 수 있게 해 준다.<br>
> 부하 균형을 명시적으로 지원하지는 않지만, SE는 NE에게 부하 균형 정보를 제공할 수 있는 방법을 제공하여, SE가 적합하다고 판단한 대로 NE가 부하 균형을 유지할 수 있도록 한다. (p537)

### 20.5 프락시 리다이렉션 방법
- 웹 브라우저가 프락시로 가는 길을 아는데는 세 가지 방법이 있다.
1. 명시적 브라우저 설정
- 사용자가 직접 브라우저 메뉴에서 프락시 이름, 아이피 주소, 포트번호를 설정하는 것이다. 여기에는 중요한 단점이 있는데, 프락시를 사용하도록 설정된 브라우저들은 프락시에 문제가 있을 경우에도 서버와 접촉하지 않아 사용자는 접속 문제를 경험하게 된다. 또한, 네트워크 아키텍처에서 변경사항이 발생했을 시 최종 사용자가 프락시 설정을 직접 변경해야만 한다는 번거로움이 있다.

2. 프락시 자동 설정
- 명시적 브라우저 설정의 단점은 사용자가 브라우저에 개입하여 프락시를 설정하므로 변경에 대응하기 어렵다는 점인데, 자동 설정을 이용하면 브라우저가 동적으로 프락시를 설정한다. 이는 프락시 자동설정(Proxy Auto-configuration, PAC) 프로토콜이 지원한다. 벤더 별 브라우저마다 PAC 파일을 요청하는 함수를 호출하도록 되어있고, 서버는 PAC 파일을 스크립트와 함께 돌려보내는데, 그 안에는 요청한 URL이 특정 도메인 안에 있다면 바로 접근하고, 아니면 프록시로 가라고 명령하는 함수가 들어 있다.
> PAC 프로토콜은 상당히 강력하다. 자바스크립트 프로그램은 브라우저에게, DNS 주소나 서브넷, 심지어 요일이나 시각과 같은 호스트 명과 관련된 여러 매개변수에 근거하여 프락시를 선택하도록 요구할 수 있다. 프락시의 위치가 변경된 경우 이를 반영하기 위해 PAC 파일이 서버에서 업데이트되기 때문에 PAC은 브라우저가 자동으로 네트워크 아키텍처 안에서의 변경에 맞는 올바른 프락시에 접촉할 수 있도록 해줄 수 있다. 오늘날 PAC는 미리 설정된 브라우저처럼 몇몇 주요 ISP들에 의해 사용되고 있다.(p540)

### 20.7 인터넷 캐시 프로토콜
- 캐시는 근처 캐시 중에 관련 콘텐츠를 갖고 있는 게 있는지 찾아본 다음 있으면 그 캐시에서 콘텐츠를 가져온다.
- 인터넷 캐시 프로토콜(ICP)는 근처 캐시 모두에게 특정 URL을 갖고 있는지 한 번에 물어보기 위한 *객체 발견 프로토콜*이다.
- 근처 캐시들은 해당 URL을 갖고 있으면 HIT, 아니면 MISS로 답한다.
- ICP 메시지는 데이터 손실이 발생할 수 있는 UDP 다이어그램으로 전송되기 때문에 타임아웃 설정이 필요하다.
- ICP 메시지는 다음 요소로 구성된 32비트 구조체다.
   - OP 코드 : ICP 메시지의 의미를 서술하는 8비트 값이다. 기본 OP 코드는 ICP_OP_QUERY 요청 메시지이고 ICP_OP_HIT와 ICP_OP_MISS 응답 메시지이다.
   - 버전 : ICP 프로토콜의 버전 번호를 서술한다.
   - 메시지 길이 : ICP 메시지의 총 길이를 바이트 단위로 나타낸 것으로, 16비트 안에 들어간다.
   - 요청 번호 : 여러 요청과 응답을 추적하기 위해 고유 번호를 갖고 있다.
   - 옵션 : ICP 동작을 변경하는 플래그를 담은 비트 벡터이다.
   - 옵션 데이터 
   - 발송자 호스트 주소
   - 페이로드 : 요청 메시지. ICP_OP_QUERRY라면 요청자 호스트 주소와 NUL로 끝나는 URL이 들어가고, ICP_OP_HIT_OBJ라면 NUL로 끝나는 URL, 16비트 객체 크키, 객체 데이터가 순서대로 들어있다.

### 20.8 캐시 배열 라우팅 프로토콜
- 캐시 프락시는 원 서버로 갈 요청을 가로채어 원 서버의 부담을 줄여주지만, 사용자가 증가할 경우 대규모 트래픽은 프락시에도 부하를 준다.
- 해결책은 프락시를 여러 대로 늘려서 분산하는 것이고, 이를 위한 프로토콜이 캐시 배열 라우팅 프로토콜(CARP)이다.
- 프락시 서버 무리는 각 무리의 서버를 나열한 테이블을 생성하며, 테이블의 엔트리는 부하 인자에 대한 정보, 생존시간 카운트다운 값, 구성원들이 얼마나 자주 폴링되어야 되는지 등에 대한 전역 매개변수가 포함돼야 한다.
> - 참여하는 프락시 서버의 테이블을 유지한다. 이 프락시 서버들은 각각이 살아 있는지 알아보기 위해 주기적으로 폴링한다.<br>
> - 각 참여 프락시 서버들에 대해 해시 함수를 계산한다. 해시 함ㅅ후가 반환하는 갑승ㄴ 이 프락시가 처리할 수 있는 부하의 양을 계산에 넣는다.<br>
> - 요청된 웹 객체의 URL에 근거한 숫자값을 반환하는 분리된 해시 함수를 정의한다.<br>
> - URL의 해시 함수와 프락시 서버의 해시 함수의 합계로 값의 배열을 얻는다. 이 값들에 대한 최댓값이 그 URL을 위해 사용할 프락시 서버를 결정한다. 계산값이 결정적이기 때문에, 같은 웹 객체에 대한 뒤이은 요청은 같은 프락시 서버로 포워딩될 것이다. (p556)<br>

- CARP의 장점은 캐시를 프락시 그룹을 하나의 캐시 집단으로 만들어 프락시 간 트래픽을 줄이고 웹 캐시에 대한 사본을 줄여 캐시 시스템이 웹 객체를 더 많이 보관할 수 있게 한다.
> 하지만 어느 하나의 프락시가 실패하더라도 상당량의 캐시 콘텐츠를 재배치해야 한다는 단점이 있다.(p557)

### 20.9 하이퍼텍스트 캐싱 프로토콜
- HTTP/1.1 이후 ICP처럼 단순히 URL만을 캐시 존재 확인 용으로 보내는 것만으로는 정확한 응답을 받는 데 무리가 있다.
- HTCP 또한 객체 발견 프로토콜일 뿐이며, 요청과 응답의 상세함 정도가 다르다.
- 메시지 필드 구성은 다음과 같다.
  - 헤더 : 모든 헤더, 데이터, 인증 크기를 포함한 32비트 메시지 길이, 8비트 주 프로토콜 버전, 8비트 부 프로토콜 버전
  - 데이터 : 데이터 길이, OP코드, 응답 코드, F1(), RR(요청인지 응답인지 알려주는 1비트 플래그), 트랜잭션 아이디(요청자의 네트워크 주소와 결합된 HTCP 식별자), OP 코드 데이터
