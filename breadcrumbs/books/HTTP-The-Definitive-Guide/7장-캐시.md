 - 웹 캐시는 문서의 사본을 로컬에 보관한다.
 - 클라이언트 요청 시 캐시된 사본이 존재한다면, 불필요한 요청 자체, 네트워크 비용, 먼 거리의 원 서버에서 오는 응답을 기다리는 시간을 줄일 수 있다.
 - 캐시가 중요한 이유는 다음과 같다.
 
### 7.1 불필요한 데이터 전송
 - 여러 클라이언트가 원 서버에 요청할 경우, 서버는 클라이언트들에게 같은 문서를 여러번 전송한다.
 - 이는 네트워크 대역폭 낭비이며, 서버에 부담을 준다.
 - 한 번 요청했을 때 서버 응답을 캐싱했다가, 뒤이은 요청에는 사본으로 응답한다면 불필요한 중복 전송을 안 해도 된다.
 
### 7.2 대역폭 병목
 - 원격 서버보다 로컬 네트워크 클라이언트가 가용 대역폭이 더 크다.
 - WAN이 아닌 LAN에 있는 캐시에서 정보를 가져온다면 특히 큰 문서의 경우 캐시 성능을 더 높일 수 있다.
 https://purple.ai/blogs/whats-the-difference-between-a-lan-and-a-wan/  <--- LAN, WAN, 대역폭
 
### 7.3 갑작스런 요청 쇄도(Flash Crowds)
 - 특별한 사건으로 인해 트래픽이 급증할 경우 웹 서버가 받는 부하가 당연히 매우 커지므로 캐싱이 중요하다.
 
### 7.4 거리로 인한 지연
 - 대역폭 얘기를 하지 않더라도, 원 서버와의 물리적 거리가 멀 수록 응답 지연이 발생한다. 캐시를 두어 문서 전송 거리를 줄이는 것은 매우 중요하다.
 
### 7.5 적중과 부적중, 재검사(Revalidation)
 - 캐시에 요청에 부합하는 사본이 있으면 적중(cache hit), 없으면 부적중(cache miss)이라 부른다.
 - 부적중 시 원 서버에 요청이 전달된다.
 - 재검사는 캐시 사본이 오래됐을 경우에 최신인지 원 서버에 확인 요청을 보내는 것이다.(If-Modified-Since 헤더) 
 - 서버로부터 304 Not Modified 응답을 받으면(재검사 적중) 임시로 신선한 캐시임을 표시한 뒤 클라이언트로 보낸다.
 - 재검사 적중 시 캐시 적중보단 시간이 좀 더 걸리지만, 원 서버로부터 객체를 새로 받아올 필요는 없으므로 캐시 부적중보단 빠르다.
 > 재검사 부적중 시 서버는 콘텐츠 전체와 함께 200 OK 응답을 클라이언트에게 보낸다.
 > 서버 객체가 삭제되었따면, 404 Not Found 응답을 돌려보내며, 캐시는 사본을 삭제한다. (p192)
 - 캐시 적중률(100%는 모든 요청을 캐시에서 가져올 수 있는 경우)는 높을 수록 좋지만 예측이 어려우므로 40%만 되어도 괜찮은 편이다.  
 - 바이트 단위 적중률이 100%일 경우 모든 바이트가 캐시에서 왔고, 어떤 트래픽도 인터넷으로 나가지 않았음을 의미한다.
 
 > 문서 적중률과 바이트 단위 적중률은 둘 다 캐시 성능에 대한 유용한 지표다. 
 > 문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여준다.
 > 트랜잭션은 고정된 소요 시간을 포함하게 되는데, 이것은 종종 길 수도 있기 때문에(예를 들어 서버로의 TCP 커넥션을 맺는 경우), 문서 적중률을 개선하면 전체 대기시간(지연)이 줄어든다. 바이트 단위 적중률은 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여준다.
 > 바이트 단위 적중률의 개선은 대역폭 절약을 최적화한다. (p193)
 
 - 응답이 캐시 적중이었는지 부적중이었는지 구별하는 방법은, Date 헤더 값이 현재 시간보다 오래되었는지 확인하거나 Age 헤더를 참고하는 것이다.
 
 ### 7.6 캐시 토폴로지
 - 개인 전용 캐시 : 웹 브라우저는 PC의 디스크나 메모리에 문서를 캐시하고, 사용자가 캐시 사이즈나 설정을 수정하고, 캐시된 콘텐츠를 볼 수 있는 기능을 제공한다. 
 - 공용 프락시 캐시 : 공용 캐시는 프락시 '서버'다. 여러 사용자가 접근하기 때문에 작은 캐시 ---> 큰 캐시(더 많은 사용자가 사용하는 큰 문서들) 순으로 여러 프락시를 두어 계층형 캐시를 구성할 수 있다.
 - 캐시 계층이 깊을 수록, 체인이 많을 수록 각 프락시 성능은 저하된다.
 
 **캐시망, 콘텐츠 라우팅, 피어링**
  - 캐시 계층에서 나아가, 캐시망을 갖는 네트워크도 있다.
  - 캐시망에서 프락시 캐시는 서로 어떤 캐시와 대화할지, 원 서버로 요청을 전달할 지에 대한 결정을 동적으로 내릴 수 있다.
  - 여기서 일어나는 행위가 콘텐츠 라우팅과 피어링이며, 이는 URL에 근거하여 특정 캐시나 서버를 동적으로 선택하고, 캐시에게 가기 전 로컬 캐시를 찾아보고, 다른 캐시가 콘텐츠에 부분 접근할 수 있도록 허용한다.
  
 ### 7.7 캐시 처리 단계
  1. 요청 받기 : HTTP 요청 메시지를 받는다.
  2. 파싱 : 헤더를 자료구조에 담아 처리하기 쉽게 만든다.
  3. 검색 : 파싱한 헤더에서 URL을 알아낸 다음 그에 맞는 로컬 사본이 있는지 찾는다. 로컬에 없으면, 부모 프락시에서 가져오거나 원 서버로 전달하거나 실패를 반환한다.
  4. 신선도 검사 : 너무 오래된 문서는 원 서버로 요청해 신선도를 검사한다. 
  5. 응답 생성 : 캐시된 원 서버 응답 헤더를 기반으로 생성하되, HTTP 버전에 따라 헤더를 조정해야 하고, 헤더에 신선도 정보(Cache-Control, Age, Expires 헤더)와 프락시 캐시(를 거쳤을 경우) 정보를 Via 헤더에 표시한다.
  6. 전송 : 클라이언트에게 전송한다.
  7. 로깅 : 캐시 적중과 부적중 횟수 등에 대한 통계를 갱신하고, 로그 파일에 요청 종류, URL 등의 항목을 추가한다.
  
 ### 7.8 사본을 신선하게 유지하기
 - HTTP는 캐시된 사본이 서버와 일치하도록 유지하는 메커니즘을 갖고 있는데, 이를 문서 만료와 서버 재검사라고 부른다.
 - **문서 만료** : `Cache-Control`과 `Expires` 헤더를 이용해서 문서에 유효기간을 부여한다.
 - **서버 재검사** : 유효기간이 만료됐다면, 원 서버에게 문서 변경 여부를 검사한다. 재검사 결과 콘텐츠가 변경되었다면 새로운 사본을 가져와 대신 저장한 뒤 클라이언트에게도 보내준다. 변경되지 않았다면 캐시의 헤더만 갱신한다.
 - **조건부 메서드** : HTTP는 캐시가 갖고 있는 사본이 다를 경우에만 객체의 본문을 가져오도록 요청할 수 있다.(조건부 GET) 조건부 GET은 `If-Modified-Since` 헤더나 `If-None-Match` 헤더가 추가됨으로써 시작된다.
 - 엔터티 태그 재검사 : 변경 일시를 기준으로 재검사하기 어려운 경우(시간별 갱신은 하지만 실 콘텐츠는 동일한 경우, 사소한 변경, 변경 일시 판별이 어려운 경우 시간 정밀도가 충분하지 않은 경우 등) `If-None-Match` 조건부 헤더를 사용함으로써, 엔터티 태그 변경 여부를 기준으로 재검사할 수 있다.
 - 캐시 검사기 : 엔터티 태그와 최근 번경일시를 말하는데, 문서를 살짝 고치는 정도는 허용하고 싶다면 약한 검사기(weak validator)를 지원하기 위해 'W/' 접두사를 헤더에 추가한다. 어떤 변경도 허용하지 않으면 강한 검사기(strong validator)를 적용한다.
 - 참고 https://developer.mozilla.org/en-US/docs/Web/HTTP/Conditional_requests
 
 ### 7.9 캐시 제어
 https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control<br>
 - Cache-Control에 no-store, no-cache, must-revalidate, max-age 헤더를 추가하거나, Expires 날짜 헤더를 사용하거나, 만료 정보 없이 휴리스틱하게 결정
 - no-store : 캐시가 그 응답의 사본을 만드는 것을 금지. 클라이언트에게 전달하고 나면 객체는 삭제
 - no-cache : 로컬 캐시에 저장될 순 있지만, 서버와 재검사해야 클라이언트로 전달 가능.
 - max-age 응답 헤더 : 사본이 신선하다고 여겨질 수 있는 시간을 지정
 - must-revalidate 응답 헤더 : 원 서버와의 재검사 없이는 제공해서는 안 됨을 의미.


