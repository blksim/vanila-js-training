### 12.1 인증
- HTTP의 인증요구/응답 프레임워크 : HTTP는 인증에 필요한 자체적인 프레임웍을 제공한다. HTTP 요청을 받으면, 서버는 개인정보를 요구하도록 응답한다.
클라이언트가 입력한 인증 정보가 맞을 경우에만 요청이 처리된다. (요청 -> 인증 요구 -> 인증 -> 성공)
- 인증 프로토콜과 헤더 : 제어 헤더를 통해, 다른 제어 프로토콜에 맞게 확장할 수도 있다. 
  - 인증 요구 : WWW-Authenticate 헤더 서버는 401 Unauthorized 상태 정보와 함께 인증을 요구한다.
  - 인증 : Authorization 클라이언트는 요청 시 인증 알고리즘, 사용자 이름, 인코딩된 비밀번호 등 인증 파라미터를 기술한 헤더를 함께 보낸다.
  - 성공 : Authorization-info 서버가 인증 세션에 대한 추가 정보를 선택적으로 헤더에 추가해 응답하는 경우
> (옮긴이) 현대에 HTTP의 인증요구/응답 프로토콜을 사용하는 인증 프로토콜로는 OAuth가 있다. OAuth는 모바일 기기 같은 다양한 애플리케이션에서 API 인증을 위해 사용하는 최신 인증 프로토콜이다.(p323)
- WWW-Authenticate 헤더 뒤에 붙는 `realm` 지시자는 보안 영역마다 다른 사용자 권한에 대해 기술(해설)하기 위해 사용한다. 

### 12.2 기본 인증
- 기본 인증은, 서버가 클라이언트의 요청 처리를 거부하고 401 Unauthorized 상태 정보와 함께 접근하려 했던 보안 영역을 WWW-Authenticate 헤더에 기술하여
인증을 요구하는 방식이다. 응답 시 사용자로부터 계정 정보를 입력받는 대화상자가 표시되고, 입력된 인증 정보는 암호화되어 Authenticate 헤더에 실린다.
- Base-64 사용자 이름/비밀번호 인코딩 : 기본 인증에서는 사용자 이름과 비밀번호를 콜론(:)으로 이은 다음, 8비트 바이트 시퀀스를 6비트 덩어리의 시퀀스로 변환하는 방식으로 인코딩한다.
> Base-64 인코딩은 바이너리, 텍스트, 국제 문자 데이터(어떤 시스템에서는 문제를 일으킬 수 있는) 문자열을 받아서 전송할 할 수 있게, 그 문자열을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명됐다. 전송 중에 원본 문자열이 변질될 걱정 없이 원격에서 디코딩할 수 있다.(p327)
- 프락시 인증 : 프락시에서 접근 정책을 관리할 수 있으므로, 회사에서는 LAN이나 무선 네트워크에 접근하기 전 인증 프락시를 두기도 한다. 프락시 서버에서의 인증에 쓰이는 상태코드와 헤더는 407, Proxy-Autenticate, Proxy-Autorization, Proxy-Authorization-info가 있다.

### 12.3 기본 인증의 보안 결함
1. base-64로 인코딩된 기본 인증 정보는 디코딩이 쉽다. 따라서 모든 트랜잭션을 SSL 채널을 통하게 하거나 다이제스트 인증 프로토콜을 사용하도록 고려할 수 있다.
2. 치명적이지 않은 애플리케이션에 기본 인증이 사용되더라도, 캡처한 아이디와 비밀번호를 다른 사이트에 시도하는 행위에 악용될 수 있다.
3. 인증 헤더를 건드리지 않더라도, 다른 부분을 수정하는 프락시가 개입할 경우 인증이 정상 동작하지 않을 수도 있다.
4. 가짜 게이트웨이나 서버를 식별하지 못한다. 따라서 기본 인증은 일반적인 환경에서 치명적이지 않은 경우에 한해 접근을 예방하는 데 한해 유용하게 사용될 수 있다.

