> HTTP 명세는 HTTP 메시지에 대해서 자세히 설명하고 있지만, HTTP 커넥션과 HTTP 메시지의 흐름에 관한 대한 내용은 충분히 다루지 않고 있다. HTTP 애플리케이션을 개발하고 있다면 HTTP 커넥션과 그것이 어떻게 사용되는지에 대해 잘 이해하고 있어야 한다.(p85)

### 4.1 TCP 커넥션
> 전 세계 모든 HTTP 통신은, 지구상의 컴퓨터와 네트워크 장비에서 널리 쓰이고 있는 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어진다. 세계 어디서든 클라이언트 애플리케이션은 서버 애플리케이션으로 TCP/IP 커넥션을 맺을 수 있다.
> 일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.(p85)
http://www.joes-hardware.com:80/power-tools.html 이라는 주소를 입력받은 브라우저는 7가지 단계를 수행한다.
1) 호스트명을 추출한다.
2) 호스트명에 대한 IP 주소를 찾는다.
3) 브라우저가 포트 번호를 얻는다.
4) IP주소의 80포트로 TCP 커넥션을 생성한다.
5) 브라우저가 서버로 HTTP GET 요청 메시지를 보낸다.
6) 브라우저가 서버로부터 받은 HTTP 응답 메시지를 읽는다.
7) 브라우저가 커넥션을 끊는다.

- HTTP 커넥션도 결국은 TCP 커넥션이며, 이는 신속 정확한 데이터 통신을 보장한다. 
- TCP는 IP 패킷(혹은 데이터그램)이라고 불리는 작은 조각으로 데이터를 전송한다. 
- HTTP는 HTTP, HTTPS 네트워크 프로토콜 스택의 가장 상위(애플리케이션 계층)이며, 그 아래에 HTTPS의 경우 TLS/SSL(보안 계층), TCP(전송 계층), 그 아래에 IP(네트워크 계층)이 있다.
- TCP는 세그먼트라는 단위로 데이터를 잘게 나누어 패킷에 담아 인터넷을 통해 전달한다.
- 각 패킷의 구성은 다음과 같다.
IP 패킷 헤더, TCP 세그먼트 헤더, TCP 데이터 조각
https://www.tutorialspoint.com/ipv4/ipv4_packet_structure.htm <-- IP packet structure

TCP는 포트 번호를 통해 커넥션을 유지하며, <발신지 IP주소, 발신자 포트, 수신자 IP 주소, 수신자 포트> 네 가지 값으로 유일한 커넥션을 생성한다.
커넥션들끼리 부분적으로 같은 커넥션 값을 가질 수는 있지만 모두 같을 수는 없다.

> 포트 번호는 회사 직원의 내선 전화와 같다. 회사의 대표 전화번호는 안내 데스크로 연결되고 내선전화는 해당 직원으로 연결되듯이 IP 주소는 해당 컴퓨터에 연결되고 포트번호는 해당 애플리케이션으로 연결된다.(p89)

운영체제는 TCP 커넥션 생성에 관한 여러 API를 제공하며, 
프로토콜의 핸드셰이킹, TCP 데이터 스트림과 IP 패킷 간의 분할 및 재조립에 대한 모든 세부사항이 외부로부터 숨겨진 상태에서 프로그래머는 이를 구현할 수 있다.


### 4.2 TCP의 성능에 대한 고려
- TCP는 HTTP 바로 아래 계층이므로, HTTP 트랜잭션 성능은 TCP 성능의 영향을 받는다.
*HTTP 트랜잭션 지연?*
- 트랜잭션을 처리하는 시간 자체는 TCP 커넥션을 설정하고, 요청을 전송하고, 응답을 보내는 것에 비해 얼마 되지 않는다.
- 클라이언트나 서버가 **너무 많은** 데이터를 내려받거나 동적 자원을 실행하지 않는 한.
- 대부분의 지연은 TCP 네트워크 지연 때문이다.

트랜잭션 지연 원인은 몇 가지가 있는데,
1. URI 호스트를 IP주소로 변환하는 시간이 너무 오래 걸리는 경우,
2. HTTP 트랜잭션이 수백 개 발생해서, 클라이언트 요청에 대한 서버의 커넥션 허가 응답까지의 시간이 너무 오래 걸리는 경우
3. 커넥션 맺어진 이후 서버에서 메시지를 읽어들이고 처리하는 과정에서 시간이 오래 걸리는 경우
4. 서버가 응답을 보내는 데 오래 걸리는 경우
등이 있다.

*가장 일반적인 TCP 관련 지연*

**핸드셰이크 지연**

TCP 커넥션이 핸드셰이크를 하는 순서는 다음과 같다.
1) 클라이언트가 'SYN'이라는 플래그를 가진 작은 TCP 패킷을 서버에게 보낸다.
2) 서버는 커넥션 요청을 수락한다는 의미로, 'SYN'과 'ACK' 플래그를 포함한 패킷을 클라이언트에게 보낸다
3) 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위한 확인응답 신호를 보낸다(p94)

트랜잭션이 아주 큰 데이터를 포함하지 않는 이상, 이 핸드셰이크가 지연을 발생시킨다.
> 결국, 크기가 작은 HTTP 트랜잭션은 50% 이상의 시간을 TCP를 구성하는 데 쓴다.(p94)

**확인응답 지연**
- 각 TCP 세그먼트의 수신자는 작은 확인응답 패킷을 반환하는데, 특정 시간에 받지 못하면 메시지를 다시 전송한다.
- 크기가 작은 확인응답은 보통 같은 방향으로 송출되는 데이터패킷에 편승(piggyback)되는데,
- 요청과 응답만으로 통신이 이루어지는 HTTP 특성상, 편승할 송출 데이터 패킷을 찾지 못하면 확인응답 지연 알고리즘으로 인한 지연이 발생한다.

**TCP의 느린 시작**
- TCP 커넥션은 최대 속도는 처음에 제한되었다가, 데이터가 전송됨에 따라 점점 빨라지는데, 
- 시간에 따른 이러한 조율을 'TCP의 느린 시작'이라고 하며,
- 이는 한 번에 전송할 수 있는 패킷 수를 제한함으로써 급작스러운 부하를 방지한다.
- 하지만 이 기능 때문에, 새로운 커넥션은 이미 튜닝된 커넥션보다는 느리다. 그래서 기존 커넥션을 재사용하는 "지속 커넥션"이 있다.

**네이글(Nagle) 알고리즘과 TCP_NODELAY**
- 각 TCP 세그먼트는 무조건 40바이트 가까이 되는 플래그와 헤더를 전송하기 때문에, 작은 데이터를 보낼 수록 비효율적이다
- 이를 보완해 많은 양의 데이터를 한 개의 데이터로 합쳐서 패킷 전송하는 알고리즘이 네이글 알고리즘
- 즉 세그먼트가 일정 크기에 도달하지 않으면 전송하지 않는다. 하지만 모든 패킷이 확인응답 받았을 경우, 충분한 패킷이 쌓였을 경우에는 전송한다.
- 하지만 패킷을 채우느라 (데이터를 기다리느라) 지연될 수 있고,
- 네이글 알고리즘과 확인응답 지연 알고리즘이 같이 쓰이면 확인응답에 걸리는 시간이 지연된다.
> HTTP 애플리케이션에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘을 비활성화하기도 한다.(p97)

**TIME_WAIT 누적과 포트 고갈**
- 성능 측정 시에 문제가 될 수 있다.
- TCP 커넥션이 끊어지면, 종단에서는 IP주소와 포트 번호를 메모리의 작은 제어영역에 기록해 놓고 일정 시간(2MSL 가량) 유지하는데
- 이는 그 시간 내에 같은 IP주소와 커넥션이 또 생기는 것을 막기 위함이다.
- 물론 현대 라우터는 아주 빨라서 중복 패킷 생성되는 경우는 거의 없어졌지만,
- 접속 IP 주소, 발신지 포트 조합이 제한되는 성능 측정 상황에서
- 2SML 종료 지연이 발생한다면 가용 커넥션 수가 제한되어 성능이 저하될 수 있다.

### 4.3 HTTP 커넥션 관리
**Connection 헤더**
- 현재 맺고 있는 커넥션에 대한 옵션을 제공해야 될 때 사용한다.
- 헤더 필드명에는 현재 커넥션에만 해당되는 헤더가 나열된다.
- 쉼표를 기준으로 세 가지 토큰이 값으로 주어질 수 있다.

> 1) HTTP 헤더 필드 명일 경우, 현재 커넥션에만 해당하는 헤더를 의미한다.<br>
> 2) 임시적인 토큰 값은, 커넥션에 대한 비표준 옵션을 의미한다.<br>
> 3) close 값은, 커넥션 작업이 완료되면 종료되어야 함을 의미한다.(p99)

예를 들어,

> HTTP:/1.1 200 OK<br>
> Cache-control: max-age=3600<br>
> Connection: meter, close, bill-my-credit-card<br>
> Meter: max-uses=3, max-refuses=6, dont-report<br>
> 에서 Connection 헤더는 Meter 헤더를 다른 커넥션으로 전달하면 안 되고 'bill-my-credit-card' 옵션을 적용할 것이며 이 트랜잭션이 끝나면 커넥션이 끝날 것이라고 말한다.(p100)

**순차적인 트랜잭션 처리에 의한 지연**

웹페이지에 세 개의 이미지를 로드하는 상황을 생각해보면,<br>
HTML 페이지를 로드할 때, 각 이미지를 로드할 때를 포함해 총 네 번의 트랜잭션이 발생한다.<br>
각 트랜잭션에서 새 커넥션을 필요로 한다면, 순차 처리되는 과정에서 물리적 지연 뿐 아니라 심리적인 지연을 느낄 수도 있다.<br>

HTTP 커넥션의 성능을 향상시키는 방법에는 크게 네 가지가 있다.

### 4.4 병렬 커넥션
- HTTP는 여러 개의 HTTP 트랜잭션을 병렬 처리함으로써, 지연 시간을 겹쳐 총 지연시간을 줄이는 효과.
- 하지만 병렬 커넥션을 지원한다고 하여 무조건 빠르지는 않다. 네트워크 대역폭 등의 변수가 있고, 대역폭이 좁으면 당연히 데이터를 내려받는 데 걸리는 시간이 증가할 것이다.
- 최신 브라우저는 병렬 커넥션을 지원하지만 대개 4개-8개의 적은 수만을 지원하며, 과도한 커넥션이 맺어질 경우 임의로 끊을 수 있다. 
- 항상 빠르게 내려받지 않더라도 화면에 여러 개의 객체가 동시에 보이므로 빠르다고 느껴질 수는 있다.

### 4.5 지속 커넥션
- 처리가 완료된 이후에도, 클라이언트나 서버가 끊기 전까지 계속 유지되는 커넥션을 의미한다.
- TCP의 느린 시작으로 인한 지연을 피할 수 있다.
- keep-alive 커넥션 : HTTP/1.0+, '지속' 커넥션 : HTTP/1.1

**keep-alive 커넥션**

> Connection 헤더에 Keep-Alive를 포함한 요청에 대해 서버는 같은 헤더를 포함하여 응답하고, 지원하지 않으면 헤더에 포함하지 않음으로써 커넥션이 끊어질 것이라 추정한다.
> timeout 파라미터는 커넥션 유지 시간을, max 파라미터는 몇 개의 트랜잭션을 처리할 때까지 유지할 것인지를 의미한다(p107)
- keep-alive 커넥션은 dumb proxy 서버와는 맺어지면 안 된다. Keep-Alive를 포함한 Connection 헤더를 이해하지 못한 채로 다음 서버에 그대로 전달할 경우, 다음 서버는 Keep-Alive 헤더를 포함해 응답함으로써 프락시 서버는 계속 커넥션이 끊어지기만을 기다리게 된다. 
- 이렇게 다음 서버로 전달되면 안 되는 홉별 헤더(Hop by hop)가 전달되는 문제를 해결하기 위해, 넷스케이프는 Proxy-Connection 헤더라는 비표준 확장 헤더를 지원함으로써 프락시가 Keep-Alive 요청을 인지하고, 다음 서버에 전달할 때는 Connection 헤더를 자체 전송할 수 있도록 한다.

**HTTP/1.1의 지속 커넥션**
- keep-alive와 달리 Connection 헤더값에 close가 전달되기 전까지 커넥션을 계속 유지하는 것으로 추정한다.
- 하지만 언제든지 커넥션을 끊을 수 있다.
- 전달되는 메시지는 항상 정확한 Content-Length 값과 청크 인코딩으로 인코드되어 있어야 한다.

### 4.6 파이프라인 커넥션
https://en.wikipedia.org/wiki/Protocol_pipelining
- 여러 요청을 응답이 오기 전까지 큐에 쌓아두는 방식
- 한 요청에 대한 응답을 기다렸다가 다음 요청을 처리하는 방식이 아니므로,
- 네트워크 왕복 시간이 길 경우에 대기 시간을 줄여줄 수 있다
- 클라이언트는 요청이 언제 끊기더라도 재 요청할 준비가 되어 있어야 한다.
- POST 요청같은, 반복해서 보낼 시 문제가 생길 수 있는 요청을 파이프라이닝할 경우 큐에 쌓여있는 요청 중 어느 것인지 알 수가 없다.

> The speedup is less apparent on broadband connections, as the limitation of HTTP 1.1 still applies: the server must send its responses in the same order that the requests were received—so the entire connection remains first-in-first-out[1] and HOL blocking can occur. The asynchronous operation of HTTP/2 and SPDY are solutions for this.[5] Browsers ultimately did not enable pipelining by default, and by 2017 most browsers supported HTTP/2 by default which used multiplexing instead.[2] (https://en.wikipedia.org/wiki/HTTP_pipelining)

### 4.7 커넥션 끊기에 대한 미스터리
- TCP 커넥션은 양방향 구조로, 한쪽의 입력 큐에 있는 데이터가 다른 쪽의 출력 큐에 보내지는 식이다.
- 언제 커넥션이 끊기는 지에는 명확한 기준이 없다.
- 커넥션은 에러가 발생하지 않아도 끊길 수 있는데, 특히 요청 데이터가 전송되었지만 서버가 응답하기 전 커넥션이 끊기는 경우 클라이언트는 요청을 다시 하기 전 이전 요청에 대한 응답을 기다려야 한다.
> 비멱등인 메서드나 순서에 대해 에이전트가 요청을 다시 보낼 수 있도록 기능을 제공한다 하더라도, 자동으로 재시도하면 안 된다. 예를 들어 대부분 브라우저는 캐시된 POST 요청 페이지를 다시 로드하려고 할 때, 요청을 다시 보내기를 원하는지 묻는 대화상자를 보여준다.
- 애플리케이션은 TCP 입력/출력 채널 전체를 끊거나, 둘 중 하나(절반)을 끊을 수 있다.

**TCP 끊기와 리셋 에러**

> 보통은 커넥션의 출력 채널을 끊는 것이 안전하다.
> 커넥션의 입력 채널을 끊으면, 이미 끊긴 입력 채널에 메시지를 보냈을 때 서버 운영체제는 심각한 에러로 취급하여 버퍼에 저장된 데이터를 모두 삭제한다.(p118)

**우아한 커넥션 끊기**

> 애플리케이션 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것이다.
> 커넥션을 우아하게 끊고자 하는 애플리케이션은 출력 채널에 절반 끊기를 하고 난 후에도 데이터나 스트림의 끝을 식별하기 위해 입력 채널에 대해 상태 검사를 주기적으로 해야 한다.(p119)
