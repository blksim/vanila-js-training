https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Declarations<br>
https://medium.com/@ethannam/javascripts-memory-model-7c972cd2c239<br>
https://developer.mozilla.org/en-US/docs/Glossary/undefined<br>
https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf<br>
https://velog.io/@godori/JavaScript-engine-1<br>
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management<br>
https://blog.sessionstack.com/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks-3f28b94cfbec<br>
https://steemit.com/kr/@cicada0014/2wvmzm-javascript<br>

### 1-1 데이터 타입의 종류
데이터 타입이란 자바스크립트 엔진(개발자가 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 바꾸는 역할을 수행하는 애플리케이션)에서 이해할 수 있는 데이터의 종류라고 쉽게 생각하면 된다.
이 데이터 타입은 크게 기본형과 참조형으로 나뉜다.
데이터 타입에 어떤 게 들어가는지는 그냥 암기하는 게 낫다.
하지만 기본형과 참조형의 차이점은 매우 중요하다.
공통점 : 변수에 접근할 때, 변수에 저장된 게 값이 아니라 값이 있는 위치, 그러니까 메모리 주소임. 
차이점 : 기본형은 변수에 일대 일로 대응하는 값 하나가 어디에 있는지 나타내는 메모리 주소값을 한 번만 복제하면 되지만, 참조형은 값이 담긴 주소에 도달할 때까지 주소값을 거듭 복제해야한다는 점이 다르다.
확실한 것 : 데이터의 위치를 가리키는 변수값(메모리 주소)는 바뀔 수 있지만, 기본형 데이터는 무조건 원본 불변한다.
자바스크립트는 동적 타입 언어이기 때문에, 자바같은 정적 타입 언어처럼 변수명 앞에 내가 이 변수의 타입이 뭐고, 얼마만큼의 메모리를 할당할 건지 미리 정해주지 않는다. 이것은 엔진이 프로그램을 실행하는 시점에 판단하게 된다.
그럼 var, const, let은 왜 붙일까? 런타임에서 변수의 scope, 재할당 제한하기 위해서

### 1-2 데이터 타입에 대한 배경지식
변수와 식별자를 구분하는 방법은 간단하다. 
변할 수 있는 데이터 자체를 변수라고 보면 되고
그 변수를 구분할 수 있게 해주는 도구, 이름표를 변수명 혹은 식별자 라고 보면 된다.
cf. 변수는 데이터 자체, 리터럴은 변수 초기화 구문에서 등호(=) 우항에 위치한 값 자체를 의미

### 1-3 변수 선언과 데이터 할당
####변수 선언이라는 행위
내가 어떤 데이터를 나중에 또 쓰려고 하는 데<br>
데이터를 똑같이 또 입력하기는 싫고, 어디 임시로 상자에 넣어 놓고 싶다.<br>
아직 무슨 데이터를 넣을 지는 모르겠다. 하지만 들어갈 상자, 그릇정도는 만들어 놓고,<br>
나중에 찾아가야 되니까 이름도 붙여주자<br>

> = 메모리 영역에 빈 공간 하나를 확보하고, 그 공간을 찾아가기 위한 이름만 저장된 상태

#### 변수에 값을 할당한다는 행위
> 이 상자 크기가 얼마나 되는지는 모르겠지만, 일단 만들었으니까 데이터를 저장해보자.

- 저장하려는 데이터가 숫자일 경우, 할당할 메모리 크기는 고정돼있다. 8비트(64바이트). 그 크기 안에서 데이터가 바뀌는 것은 추가적인 공간 확보가 필요 없다.
- 메모리 성능이 예전에 비해 향상되었기 때문에 타입별 메모리 할당 크기에 대해 덜 신경쓰게 된 것도 있고, 런타임에 알아서 할당을 하기 때문에 정확히 메모리가 얼만큼 할당되는 지도 알 수 없지만,
- 문자열의 경우 문자열을 구성하는 한 글자마다 필요한 메모리 용량이 다르기 때문에 값의 변화가 생겼을 경우, 메모리 공간도 줄었다 늘었다 하게 생김.
- 곧 값의 변화는 컴퓨터가 해야할 연산이 증대되는 것을 의미하고, 이는 부하와 프로그램 성능 저하를 의미한다.
- 그래서 문제 해결을 위해, 데이터가 바뀌면 기존 데이터는 냅두고, 아예 새로운 공간에 데이터를 저장하고, 그 공간을 찾아가기 위한 주소를 변수에 저장한다.

### 메모리에서 일어나는 일
- 자바스크립트는 런타임에 메모리를 ‘동적 할당’한다.
- 메모리는 여러 개의 데이터를 기억해두기 위한 저장공간이다.

#### 언어 불문, 메모리 공간에서는 항상 이런 일이 끊임없이 일어나고 있다.
- 필요한 만큼 메모리를 배정한다.(변수에 값 할당 시 메모리 할당도 같이 일어남)
- 할당된 메모리를 실제로 사용한다.
- 메모리에 저장된 데이터를 읽거나
- 메모리에 새로 데이터를 덮어쓴다.
- 변수나 객체 프로퍼티의 값을 읽거나 쓸 때, 함수에 인자 전달할 때
- 더 이상 필요없는 메모리는 놔준다.
			- 더 이상 필요없는 메모리를 어떻게 판단할까.
			- 저수준 언어의 경우 개발자가 직접 메모리를 해제해줘야 하지만,
			- 고수준 언어일 경우 가비지 컬렉터라는 소프트웨어가 엔진에 임베드되어있기 때문에 필요 없음.


### 1-4 기본형 데이터와 참조형 데이터
불변 가변 개념은 값에 한정된 개념
즉, 순수한 데이터가 저장되는 메모리의 데이터 영역에서, 데이터 변경 시 원본 데이터가 오염되느냐 아니냐가 불변 가변을 가른다.
(원본 값이) 불변한다 : 원본 데이터 그대로 있고, 변경 데이터를 저장하기 위한 메모리 공간이 데이터 영역에 새로 생긴다.
(원본 값이) 가변한다 : 데이터 영역 속 같은 공간에서 원본 데이터를 계속 변경 가능하다. 

### 1-5 불변 객체
- 불변 객체 역시 객체라는 데이터 그 자체가 아니라 내부 프로퍼티를 변경할 때 성립된다.
- 그러니까, 프로퍼티값은 변경이 되더라도 그 객체 자체는 
- 얕은 복사 : 딱 한 단계 밑의 프로퍼티 값까지만 복사됨
- 깊은 복사 : 프로퍼티 값 속의 프로퍼티 값까지 재귀적으로 복사됨.

### 1-6 Undefined와 Null
기본형 데이터 타입에 속하므로, 그 자체로 타입인 동시에 ‘값’에 해당<br>
**undefined**
- 사용자가 리터럴로 undefined 할당하는 경우 -> ‘값’
- 참조형 데이터의 요소나 프로퍼티 값으로 할당했을 경우, 배열 메서드가 이를 ‘존재하는 값’으로 보고 순회함
- 엔진이 런타임에 ‘반환’하는 경우가 있다. -> ‘상태’에 가깝다
- 값을 할당하지 않은 변수에 접근할 경우
- 존재하지 않는 객체 프로퍼티에 접근할 경우
- return문이 없거나 호출되지 않는 함수의 실행 결과
**null**
- 개발자가 직접 null을 변수에 할당했을 때 ‘아무것도 없음’이라는 값을 할당한 것임. 
- undefined를 직접 할당하는 대신 null을 할당하면 됨.



